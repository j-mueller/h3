-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core library for h3
--   
--   This package provides the core types for h3
@package h3-core
@version 0.0.1

module Data.H3.Extent
newtype Extent a
Extent :: (Min a, Max a) -> Extent a
[getExtent] :: Extent a -> (Min a, Max a)
_Extent :: forall p f a b. (Profunctor p, Functor f) => p (Extent a) (f (Extent b)) -> p (a, a) (f (b, b))
extent :: a -> Extent a
toTuple :: Extent a -> (a, a)
fromTuple :: (a, a) -> Extent a

-- | Change the size of an [[Extent]] symmetrically
resize :: (Fractional a, Num a) => a -> Extent a -> Extent a
instance Data.Traversable.Traversable Data.H3.Extent.Extent
instance Data.Foldable.Foldable Data.H3.Extent.Extent
instance GHC.Generics.Generic (Data.H3.Extent.Extent a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.H3.Extent.Extent a)
instance GHC.Base.Functor Data.H3.Extent.Extent
instance GHC.Show.Show a => GHC.Show.Show (Data.H3.Extent.Extent a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.H3.Extent.Extent a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.H3.Extent.Extent a)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.H3.Extent.Extent


-- | Type classes for scales. A scale is a family of functions that are
--   parameterised by a target range (for example, the dimensions of the
--   diagram in pixels) and an additional set of options specific to each
--   scale.
--   
--   In <tt>h3</tt>, <a>Scalable</a> is the type class that represents
--   scales. Scales used for visualisation commonly have metadata such as
--   legends, grid lines etc. The <a>ChartVisuals</a> class deals with this
--   kind of data.
module Data.H3.Scalable

-- | The class of scales. Each scale has an associated data type
--   <a>ScaleOptions</a> that can be used to configure the scale.
class Scalable (f :: * -> *) a b where {
    type family Target f :: * -> *;
    type family TargetRange f b :: *;
    data family ScaleOptions f a b :: *;
}

-- | Given <a>ScaleOptions</a> and a <a>TargetRange</a>, produce a map 'a
--   -&gt; (Target f) b'.
scale :: Scalable f a b => (ScaleOptions f) a b -> TargetRange f b -> a -> (Target f) b

-- | Every function 'f :: a -&gt; b' is a scale
arrow :: (a -> b) -> ScaleOptions ((->) a) a b
instance Data.H3.Scalable.Scalable ((->) a) a b

module Data.H3.Utils

-- | Generate a list of "nice" numbers that contain the given interval.
--   
--   Based on "Nice numbers for label graphs" by Paul Heckbert.
--   <a>http://www.realtimerendering.com/resources/GraphicsGems/gems/Label.c</a>
looseLabels :: (Ord a, Num a, Fractional a, Floating a, RealFrac a) => LabelCount -> (a, a) -> (NonEmpty a, Integer)

-- | How many labels to generate
newtype LabelCount
LabelCount :: Integer -> LabelCount
defaultLabelCount :: LabelCount
data RoundingMode
Round :: RoundingMode
DontRound :: RoundingMode
nicenum :: (Ord a, Num a, Fractional a, Floating a, RealFrac a) => RoundingMode -> a -> a
linear :: (Fractional a, Eq a) => (a, a) -> (a, a) -> a -> a
computeMidpoint :: (Fractional x, Num x, Foldable1 f) => f x -> x


-- | A set of useful scales for visualising data. Each scale is identified
--   by an empty data type (<a>Continuous</a>, <a>Ordinal</a> etc). To use
--   a scale <tt>f</tt> to map <tt>a</tt>s to <tt>b</tt>s you need to
--   construct a value of <tt>ScaleOptions f a b</tt>. To make this easier,
--   a constructor such as <a>continuous</a>, <a>ordinal</a>, etc. is
--   provided for each scale.
--   
--   Scales can be combined in a number of ways, just like to ordinary
--   functions. For example, we can take the <a>Product</a> of any two
--   scales <tt>f</tt> and <tt>g</tt>. The <a>ScaleOptions</a> of combined
--   scales are usually functions of the <a>ScaleOptions</a> of their
--   components, and can be constructed in the same way.
module Data.H3.Scales

-- | Every function 'f :: a -&gt; b' is a scale
arrow :: (a -> b) -> ScaleOptions ((->) a) a b

-- | Create a continuous scale (map between real numbers).
continuous :: Extent a -> IncludeZeroPolicy -> ScaleOptions Continuous a a
data Continuous a

-- | Indicates whether to extend the source (domain) of a continuous scale
--   to include 0.
--   
--   Extending the scale to 0 ensures that absolute values are comparable
--   but may obscure differences between values if the variation of the
--   data is small compared to its absolute size.
data IncludeZeroPolicy
IncludeZero :: IncludeZeroPolicy
DontIncludeZero :: IncludeZeroPolicy

-- | Create a cardinal scale (map from integers to <a>Double</a>).
cardinal :: Extent a -> ScaleOptions Cardinal a Double
data Cardinal a

-- | Create an ordinal scale (map from some type with an <a>Ord</a>
--   instance to 'Extent Double').
ordinal :: NonEmpty a -> (a -> String) -> ScaleOptions Ordinal a Double
data Ordinal a

-- | The product of two scales.
product :: ScaleOptions f a b -> ScaleOptions g c d -> ScaleOptions (Product f g) (a, c) (b, d)
newtype Product f g a
Product :: (f (LeftV a), g (RightV a)) -> Product f g a
[getProduct] :: Product f g a -> (f (LeftV a), g (RightV a))

-- | <a>nested</a> takes two scales <tt>g</tt> and <tt>f</tt> and creates a
--   <tt>g</tt> scale within each <tt>f</tt> result. This requires 'Target
--   f', <tt>Target g</tt> and <tt>TargetRange g</tt> to be identical.
nested :: ScaleOptions f a b -> ScaleOptions g c b -> ScaleOptions (Nested f g) (a, c) b
data Nested (f :: * -> *) (g :: * -> *) p

-- | Map the results of a scale monomorphically.
transformed :: (Target f b -> Target f b) -> (ScaleOptions f) a b -> ScaleOptions (Transformed f) a b
data Transformed (f :: * -> *) a

-- | Extend a scale by "anchoring" its results to a fixed point of the
--   domain
anchored :: a -> ScaleOptions f a b -> ScaleOptions (Anchored f) a b
data Anchored (f :: * -> *) a
newtype Pair a
Pair :: (a, a) -> Pair a
[getPair] :: Pair a -> (a, a)

-- | A type that is the result of a binary function
class ProductV p

-- | Additional parameters for the scale (other than target range).
instance (GHC.Base.Applicative (Data.H3.Scalable.Target f), Data.H3.Scalable.Scalable f a b) => Data.H3.Scalable.Scalable (Data.H3.Scales.Anchored f) a b
instance (Data.H3.Scalable.Target f b ~ h b, GHC.Base.Functor h, Data.H3.Scalable.Scalable f a b) => Data.H3.Scalable.Scalable (Data.H3.Scales.Transformed f) a b
instance (Data.H3.Scalable.Target g b ~ Data.H3.Scalable.TargetRange g b, Data.H3.Scalable.Target f b ~ Data.H3.Scalable.TargetRange g b, Data.H3.Scalable.Scalable f a b, Data.H3.Scalable.Scalable g c b) => Data.H3.Scalable.Scalable (Data.H3.Scales.Nested f g) (a, c) b
instance (Data.H3.Scalable.Scalable f a b, Data.H3.Scalable.Scalable g c d) => Data.H3.Scalable.Scalable (Data.H3.Scales.Product f g) (a, c) (b, d)
instance Data.H3.Scales.ProductV Data.Void.Void
instance Data.H3.Scales.ProductV (a, b)
instance Data.H3.Scales.ProductV (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Eq a) => Data.H3.Scalable.Scalable Data.H3.Scales.Ordinal a GHC.Types.Double
instance (GHC.Classes.Ord a, GHC.Real.Integral a) => Data.H3.Scalable.Scalable Data.H3.Scales.Cardinal a GHC.Types.Double
instance (GHC.Classes.Ord a, GHC.Real.RealFrac a, GHC.Float.Floating a) => Data.H3.Scalable.Scalable Data.H3.Scales.Continuous a a


-- | Shapes that make up charts.
module Data.H3.Visuals

-- | Shapes that make up charts. <tt>s</tt> is the type of colours, and
--   <tt>n</tt> the type of coordinates. For a 2D chart <tt>n</tt> should
--   be something like <tt>(Double, Double)</tt>.
data Shape s n

-- | An open line of several points
ALine :: [n] -> Shape s n

-- | A rectangle, defined by its lower left and upper right corners (if
--   <tt>n ~ (Double, Double)</tt>)
ARectangle :: !(Extent n) -> Shape s n

-- | An area (closed line)
AnArea :: [n] -> Shape s n

-- | Set the colour of a shape
AColouredShape :: s -> !(Shape s n) -> Shape s n

-- | Group several shapes together
AGroup :: [Shape s n] -> Shape s n

-- | A label
ALabel :: !TextAnchor -> !(FontSize String) -> !(FontWeight String) -> !String -> n -> Shape s n

-- | Set the opacity of a shape
AnOpacity :: Double -> !(Shape s n) -> Shape s n

-- | Empty shape
EmptyShape :: Shape s n

-- | Change the colours of a <a>Shape</a>.
mapColour :: (s -> t) -> Shape s n -> Shape t n

-- | Indicates where a text element should be anchored, that is where its
--   origin is placed relative to the text.
data TextAnchor
AnchorStart :: TextAnchor
AnchorMiddle :: TextAnchor
AnchorEnd :: TextAnchor

-- | Font size
newtype FontSize s
FontSize :: s -> FontSize s
[getFontSize] :: FontSize s -> s

-- | Font size iso
_FontSize :: forall p f a b. (Profunctor p, Functor f) => p (FontSize a) (f (FontSize b)) -> p a (f b)

-- | Font weight
newtype FontWeight s
FontWeight :: s -> FontWeight s
[getFontWeight] :: FontWeight s -> s

-- | Font weight iso
_FontWeight :: forall p f a b. (Profunctor p, Functor f) => p (FontWeight a) (f (FontWeight b)) -> p a (f b)

-- | Pixel unit in the target coordinate system
newtype Pixel a
Pixel :: a -> Pixel a
[getPixel] :: Pixel a -> a

-- | Pixel iso
_Pixel :: forall p f a b. (Profunctor p, Functor f) => p (Pixel a) (f (Pixel b)) -> p a (f b)
newtype LabelOffset a
LabelOffset :: a -> LabelOffset a
[getLabelOffset] :: LabelOffset a -> a

-- | LabelOffset iso
_LabelOffset :: forall p f a b. (Profunctor p, Functor f) => p (LabelOffset a) (f (LabelOffset b)) -> p a (f b)

-- | A collection of scale metadata that needs to be visualised. <tt>n</tt>
--   is the type of coordinates in the target coordinate system, to allow
--   combinators such as <a>Product</a> and <a>Cartesian</a> to adjust the
--   locations of the elements.
data VisualElements s n
VisualElements :: [n] -> [(n, n)] -> [(n, n)] -> [(String, n)] -> [Shape s n] -> VisualElements s n

-- | Points in the target interval that should be indicated to the user,
[veTicks] :: VisualElements s n -> [n]

-- | Start and end points of axes
[veAxes] :: VisualElements s n -> [(n, n)]

-- | Start and end points of grid lines
[veGridLines] :: VisualElements s n -> [(n, n)]

-- | Points in the target interval that should be labelled
[veAxisLabels] :: VisualElements s n -> [(String, n)]

-- | Additional data
[veLegend] :: VisualElements s n -> [Shape s n]
backgroundShapes :: VisualElements s n -> Shape String n
foregroundShapes :: VisualElements String (x, y) -> Shape String (x, y)

-- | The class of scales that have metadata in the form of
--   <a>VisualElements</a>.
class ChartVisuals c a b
visuals :: ChartVisuals c a b => c -> a -> VisualElements String b
newtype Vis a
Vis :: a -> Vis a
noGrid :: ScaleOptions f a b -> ScaleOptions (NoGrid f) a b
data NoGrid (f :: * -> *) a
noVisuals :: ScaleOptions f a b -> ScaleOptions (NoVisuals f) a b
data NoVisuals (f :: * -> *) a
cartesian :: Extent d -> Extent b -> FontSize String -> LabelOffset (b, d) -> ScaleOptions f a b -> ScaleOptions g c d -> ScaleOptions (Cartesian f g) (a, c) (b, d)
data Cartesian (f :: * -> *) (g :: * -> *) a

-- | Additional parameters for the scale (other than target range).
instance Data.Traversable.Traversable Data.H3.Visuals.Vis
instance Data.Foldable.Foldable Data.H3.Visuals.Vis
instance GHC.Base.Functor Data.H3.Visuals.Vis
instance GHC.Show.Show a => GHC.Show.Show (Data.H3.Visuals.Vis a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.H3.Visuals.Vis a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.H3.Visuals.Vis a)
instance (GHC.Show.Show n, GHC.Show.Show s) => GHC.Show.Show (Data.H3.Visuals.VisualElements s n)
instance GHC.Base.Functor (Data.H3.Visuals.VisualElements s)
instance (GHC.Show.Show n, GHC.Show.Show s) => GHC.Show.Show (Data.H3.Visuals.Shape s n)
instance Data.Traversable.Traversable (Data.H3.Visuals.Shape s)
instance Data.Foldable.Foldable (Data.H3.Visuals.Shape s)
instance GHC.Base.Functor (Data.H3.Visuals.Shape s)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.H3.Visuals.LabelOffset a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.H3.Visuals.LabelOffset a)
instance GHC.Real.Real a => GHC.Real.Real (Data.H3.Visuals.LabelOffset a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.H3.Visuals.LabelOffset a)
instance GHC.Num.Num a => GHC.Num.Num (Data.H3.Visuals.LabelOffset a)
instance GHC.Show.Show a => GHC.Show.Show (Data.H3.Visuals.LabelOffset a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.H3.Visuals.LabelOffset a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.H3.Visuals.LabelOffset a)
instance GHC.Base.Functor Data.H3.Visuals.LabelOffset
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.H3.Visuals.Pixel a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.H3.Visuals.Pixel a)
instance GHC.Real.Real a => GHC.Real.Real (Data.H3.Visuals.Pixel a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.H3.Visuals.Pixel a)
instance GHC.Num.Num a => GHC.Num.Num (Data.H3.Visuals.Pixel a)
instance GHC.Show.Show a => GHC.Show.Show (Data.H3.Visuals.Pixel a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.H3.Visuals.Pixel a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.H3.Visuals.Pixel a)
instance GHC.Base.Functor Data.H3.Visuals.Pixel
instance GHC.Generics.Generic (Data.H3.Visuals.FontWeight s)
instance GHC.Show.Show s => GHC.Show.Show (Data.H3.Visuals.FontWeight s)
instance GHC.Classes.Ord s => GHC.Classes.Ord (Data.H3.Visuals.FontWeight s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Data.H3.Visuals.FontWeight s)
instance GHC.Base.Functor Data.H3.Visuals.FontWeight
instance GHC.Generics.Generic (Data.H3.Visuals.FontSize s)
instance GHC.Show.Show s => GHC.Show.Show (Data.H3.Visuals.FontSize s)
instance GHC.Classes.Ord s => GHC.Classes.Ord (Data.H3.Visuals.FontSize s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Data.H3.Visuals.FontSize s)
instance GHC.Base.Functor Data.H3.Visuals.FontSize
instance GHC.Enum.Bounded Data.H3.Visuals.TextAnchor
instance GHC.Enum.Enum Data.H3.Visuals.TextAnchor
instance GHC.Generics.Generic Data.H3.Visuals.TextAnchor
instance GHC.Show.Show Data.H3.Visuals.TextAnchor
instance GHC.Classes.Ord Data.H3.Visuals.TextAnchor
instance GHC.Classes.Eq Data.H3.Visuals.TextAnchor
instance (Data.H3.Scalable.Scalable f a b, Data.H3.Scalable.Scalable g c d) => Data.H3.Scalable.Scalable (Data.H3.Visuals.Cartesian f g) (a, c) (b, d)
instance (Data.H3.Scalable.TargetRange f b ~ h b, Data.H3.Scalable.TargetRange g d ~ h d, h ~ Data.H3.Extent.Extent, GHC.Num.Num d, GHC.Num.Num b, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions g c d)) (h d) d, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions f a b)) (h b) b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Visuals.Cartesian f g) (a, c) (b, d))) (h b, h d) (b, d)
instance Data.H3.Scalable.Scalable f a b => Data.H3.Scalable.Scalable (Data.H3.Visuals.NoVisuals f) a b
instance (h ~ Data.H3.Scalable.TargetRange f b, Data.H3.Scalable.Scalable f a b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Visuals.NoVisuals f) a b)) h b
instance Data.H3.Scalable.Scalable f a b => Data.H3.Scalable.Scalable (Data.H3.Visuals.NoGrid f) a b
instance (h ~ Data.H3.Scalable.TargetRange f b, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions f a b)) h b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Visuals.NoGrid f) a b)) h b
instance (GHC.Classes.Ord a, GHC.Real.RealFrac a, GHC.Float.Floating a) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions Data.H3.Scales.Continuous a a)) (Data.H3.Extent.Extent a) a
instance (GHC.Classes.Ord a, GHC.Real.Integral a) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions Data.H3.Scales.Cardinal a GHC.Types.Double)) (Data.H3.Extent.Extent GHC.Types.Double) GHC.Types.Double
instance (GHC.Classes.Ord a, GHC.Classes.Eq a) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions Data.H3.Scales.Ordinal a GHC.Types.Double)) (Data.H3.Extent.Extent GHC.Types.Double) GHC.Types.Double
instance (h ~ Data.H3.Scalable.TargetRange g b, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions f a b)) h b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Scales.Nested f g) (a, c) b)) h b
instance (h ~ Data.H3.Scalable.TargetRange f b, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions f a b)) h b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Scales.Transformed f) a b)) h b
instance (h ~ Data.H3.Scalable.TargetRange f b, Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions f a b)) h b) => Data.H3.Visuals.ChartVisuals (Data.H3.Visuals.Vis (Data.H3.Scalable.ScaleOptions (Data.H3.Scales.Anchored f) a b)) h b
instance GHC.Base.Semigroup (Data.H3.Visuals.VisualElements s n)
instance GHC.Base.Monoid (Data.H3.Visuals.VisualElements s n)

module Data.H3
